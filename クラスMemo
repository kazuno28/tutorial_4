<クラス>
[コンストラクタ]
ダブルクォートを使って文字列のインスタンスを作成したが、これは文字列のオブジェクトを暗黙で作成するリテラルコンストラクタ。

>> s = "foobar"       # ダブルクォートは実は文字列のコンストラクタ
=> "foobar"
>> s.class
=> String
上のコードでは、文字列がclassメソッドに応答しており、その文字列が所属するクラスを単に返していることがわかる。


暗黙のリテラルコンストラクタを使う代わりに、明示的に同等の名前付きコンストラクタを使うことができる。
名前付きコンストラクタは、クラス名に対してnewメソッドを呼び出す。
>> s = String.new("foobar")   # 文字列の名前付きコンストラクタ
=> "foobar"
>> s.class
=> String
>> s == "foobar"
=> true
この動作はリテラルコンストラクタと等価ですが、動作の内容が明確に示されている。

配列でも、文字列と同様にインスタンスを生成できる。
>> a = Array.new([1, 3, 2])
=> [1, 3, 2]

ハッシュの場合は若干異なる。
配列のコンストラクタであるArray.new は配列の初期値を引数に取るが、Hash.new はハッシュのデフォルト 値を引数に取る。
これは、キーが存在しない場合のデフォルト値である。
>> h = Hash.new
=> {}
>> h[:foo]            # 存在しないキー (:foo) の値にアクセスしてみる
=> nil
>> h = Hash.new(0)    # 存在しないキーのデフォルト値をnilから0にする
=> {}
>> h[:foo]
=> 0

メソッドがクラス自身 (ここの場合はnew) に対して呼び出されるとき、このメソッドをクラスメソッドと呼ぶ。
クラスのnewメソッドを呼び出した結果は、そのクラスのオブジェクトであり、これはクラスのインスタンスとも呼ばれる。
lengthのように、インスタンスに対して呼び出すメソッドはインスタンスメソッドと呼ばれる。


[演習]
1. 1から10の範囲オブジェクトを生成するリテラルコンストラクタは何か？
 > a = 1..10
 => 1..10 
 
 > a.class
 => Range 
 
2. Rangeクラスとnewメソッドを使って、1から10の範囲オブジェクトを作る。
　  ヒント: newメソッドに2つの引数を渡す必要がある。
 > b = Range.new(1,10)
 => 1..10 
 
3. 比較演算子==を使って、上記２つの課題で作ったそれぞれのオブジェクトが同じであることを確認。
 > a == b
 => true


<クラス継承>
superclassメソッドを使ってクラス階層を調べてみる。

>> s = String.new("foobar")
=> "foobar"
>> s.class                        # 変数sのクラスを調べる
=> String
>> s.class.superclass             # Stringクラスの親クラスを調べる
=> Object
>> s.class.superclass.superclass  # Ruby 1.9からBasicObjectが導入
=> BasicObject
>> s.class.superclass.superclass.superclass
=> nil

これは、継承階層を示している。
ここでは、StringクラスのスーパークラスはObjectクラスで、ObjectクラスのスーパークラスはBasicObjectクラスだが、
BasicObjectクラスはスーパークラスを持たないことがわかる。

この図式は、すべての Ruby のオブジェクトにおいて成り立つ。
クラス階層をたどっていくと、 Rubyにおけるすべてのクラスは最終的にスーパークラスを持たないBasicObjectクラスを継承している。

これが、"Rubyではあらゆるものがオブジェクトである" ということの技術的な意味。
 
 [Stringクラスの継承階層]
　　　BasicObject
　　　　　↑
　　　　Object
　　　　　↑
　　　　String


Wordクラスを作成し、その中に、ある単語が回文になっていたらtrueを返すpalindrome?メソッドを作成してみる。

継承のためのRubyの Word < String 記法
>> class Word < String             # WordクラスはStringクラスを継承する
>>   # 文字列が回文であればtrueを返す
>>   def palindrome?
>>     self == self.reverse        # selfは文字列自身を表す
>>   end
>> end
=> :palindrome?
こうすることで、新しいpalindrome?メソッドだけではなく、Stringクラスが扱えるすべてのメソッドがWordクラスでも使えるようになる。

>> s = Word.new("level")    # 新しいWordを作成し、"level" で初期化する
=> "level"
>> s.palindrome?            # Wordが回文かどうかを調べるメソッド
=> true
>> s.length                 # WordはStringで扱える全てのメソッドを継承している
=> 5

WordクラスはStringクラスを継承しているので、コンソールを使ってクラス階層を明示的に確認できる。
>> s.class
=> Word
>> s.class.superclass
=> String
>> s.class.superclass.superclass
=> Object

 [組み込みではないWordクラスの継承階層]
 　　　　　　BasicObject
　　　　　　↑
　　　　　Object
　　　　　　↑
　　　　　String
　　　　　　↑
　　　　　 Word
　　　　　 
単語の文字を逆順にしたものが元の単語と同じであるかどうかのチェックを、
Wordクラスの中から自分自身が持つ単語にアクセスすることで行なっていることに注目する！

Rubyでは、selfキーワードを使ってこれを指定することができる。
Wordクラスの中では、selfはオブジェクト自身を指す。
　→self == self.reverseを使って単語が回文であるかどうかを確認できる。
　　なお、Stringクラスの内部では、メソッドや属性を呼び出すときのself.も省略可能。
　　self == reverse

　　