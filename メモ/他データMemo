<他データの構造>
 [配列と範囲演算子]
配列 (array) は、特定の順序を持つ要素のリスト。

splitメソッドを使うと、文字列を自然に変換した配列を得ることができる。
>>  "foo bar     baz".split     # 文字列を3つの要素を持つ配列に分割する
=> ["foo", "bar", "baz"]

この操作によって、3つの文字列からなる配列が得られる。
splitで文字列を区切って配列にするときにはデフォルトで空白が使われるが、次のように他の文字を指定して区切ることもできる。
>> "fooxbarxbaz".split('x')
=> ["foo", "bar", "baz"]


多くのコンピュータ言語の慣習と同様、Rubyの配列でもゼロオリジンを採用している。
これは、配列の最初の要素のインデックスが0から始まり、2番目は1...と続くことを意味する。
>> a = [42, 8, 17]
=> [42, 8, 17]
>> a[0]               # Rubyでは角カッコで配列にアクセスする
=> 42
>> a[1]
=> 8
>> a[2]
=> 17
>> a[-1]              # 配列の添字はマイナスにもなれる!
=> 17
上で示したとおり、配列の要素にアクセスするには角カッコを使う。
Rubyでは、角カッコ以外にも配列の要素にアクセスする方法が提供されている。

>> a                  # 配列「a」の内容を確認する
=> [42, 8, 17]
>> a.first
=> 42
>> a.second
=> 8
>> a.last
=> 17
>> a.last == a[-1]    # == を使って比較する
=> true
最後の行では、等しいことを確認する比較演算子==を使った。
この演算子や != (“等しくない”) などの演算子は、他の多くの言語と共通。

>> x = a.length       # 配列も文字列と同様lengthメソッドに応答する
=> 3
>> x == 3
=> true
>> x == 1
=> false
>> x != 1
=> true
>> x >= 1
=> true
>> x < 1
=> false
配列は、上記コードの最初の行のlengthメソッド以外にも、さまざまなメソッドに応答する。

>> a
=> [42, 8, 17]
>> a.empty?
=> false
>> a.include?(42)
=> true
>> a.sort
=> [8, 17, 42]
>> a.reverse
=> [17, 8, 42]
>> a.shuffle
=> [17, 42, 8]
>> a
=> [42, 8, 17]
上のどのメソッドを実行した場合にも、a自身は変更されていないという点に注目！
配列の内容を変更したい場合は、そのメソッドに対応する「破壊的」メソッドを使う。

破壊的メソッドの名前には、元のメソッドの末尾に「!」を追加したものを使うのがRubyの慣習。
>> a
=> [42, 8, 17]
>> a.sort!
=> [8, 17, 42]
>> a
=> [8, 17, 42]

また、pushメソッド (または同等の<<演算子) を使って配列に要素を追加することもできる。
>> a.push(6)                  # 6を配列に追加する
=> [42, 8, 17, 6]
>> a << 7                     # 7を配列に追加する
=> [42, 8, 17, 6, 7]
>> a << "foo" << "bar"        # 配列に連続して追加する
=> [42, 8, 17, 6, 7, "foo", "bar"]

上の例では、要素の追加をチェーン (chain) できることを示した。
他の多くの言語の配列と異なり、Rubyでは異なる型が配列の中で共存できる。(上の場合は整数と文字列)

上では、文字列を配列に変換するのにsplitを使った。
joinメソッドはこれと逆の動作である。
>> a
=> [42, 8, 17, 6, 7, "foo", "bar"]
>> a.join                       # 単純に連結する
=> "4281767foobar"
>> a.join(', ')                 # カンマ+スペースを使って連結する
=> "42, 8, 17, 6, 7, foo, bar"

範囲 (range) は、配列と密接に関係している。
to_aメソッドを使って配列に変換すると理解しやすい。
>> 0..9
=> 0..9
>> 0..9.to_a              # 9に対してto_aを呼んでしまっている
NoMethodError: undefined method `to_a' for 9:Integer
>> (0..9).to_a            # 丸カッコを使い、範囲オブジェクトに対してto_aを呼ぶ
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

0..9 は範囲として有効だが、上の2番目の表記ではメソッドを呼ぶ際にカッコを追加する必要があることを示している。

範囲は、配列の要素を取り出すのに便利。
>> a = %w[foo bar baz quux]         # %wを使って文字列の配列に変換
=> ["foo", "bar", "baz", "quux"]
>> a[0..2]
=> ["foo", "bar", "baz"]

インデックスに-1という値を指定できるのは極めて便利。
-1を使うと、配列の長さを知らなくても配列の最後の要素を指定することができ、
これにより配列を特定の開始位置の要素から最後の要素までを一度に選択することができる。
>> a = (0..9).to_a
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>> a[2..(a.length-1)]               # 明示的に配列の長さを使って選択
=> [2, 3, 4, 5, 6, 7, 8, 9]
>> a[2..-1]                         # 添字に-1を使って選択
=> [2, 3, 4, 5, 6, 7, 8, 9]

字列に対しても範囲オブジェクトが使える。
>> ('a'..'e').to_a
=> ["a", "b", "c", "d", "e"]


[演習]
1. 文字列「A man, a plan, a canal, Panama」を ", " で分割して配列にし、変数aに代入する。
 > a= "A man, a plan, a canal, Panama".split(', ')
 => ["A man", "a plan", "a canal", "Panama"] 

2. 今度は、変数aの要素を連結した結果 (文字列) を、変数sに代入する。
  > s = a.join 
 => "A mana plana canalPanama" 

3. 変数sを半角スペースで分割した後、もう一度連結して文字列にする。(ヒント: メソッドチェーンを使うと１行でもできる。)
 > s.split
 => ["A", "mana", "plana", "canalPanama"] 
 
 >s.split.join
 => "AmanaplanacanalPanama" 
 
 >palindrome_tester(s.split.join)
 It's not a palindrome.
 => nil 
 
 > palindrome_tester(s.split.join.downcase)
 It's a palindrome!
 => nil
 
4. aからzまでの範囲オブジェクトを作成し、7番目の要素を取り出す。同様にして、後ろから７番目の要素を取り出す。
   (ヒント: 範囲オブジェクトを配列に変換するのを忘れないように)
 > ('a'..'z').to_a
 => ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"] 
 
 > ('a'..'z').to_a[6]
 => "g"
 
 > ('a'..'z').to_a[-7]
 => "t" 
 