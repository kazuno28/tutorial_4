[セッション]
HTTPはステートレス (Stateless) なプロトコル。
　　→「状態 (state)」が「ない (less)」ので、HTTPのリクエスト１つ１つは、
　　　それより前のリクエストの情報をまったく利用できない、独立したトランザクションとして扱われる。

HTTPは言ってみれば、リクエストが終わると次回は何もかも最初からやり直す忘れっぽいプロトコル。
　　→ブラウザのあるページから別のページに移動したときに、ユーザーのIDを保持しておく手段がHTTPプロトコル内「には」全くない。

ユーザーログインの必要なWebアプリケーションでは、セッション (Session) と呼ばれる半永続的な接続を、
ユーザーのパソコンのWebブラウザとRailsサーバーなどに別途設定する。
　　→セッションはHTTPプロトコルと階層が異なるので、HTTPの特性とは別に接続を確保できる。

<Sessionsコントローラー>
[演習]
1. GET login_pathとPOST login_pathとの違いを説明できるか考えてみる。
 GET login_path は、取得ときで、POST login_path は、登録する時に使う。

2. ターミナルのパイプ機能を使ってrails routesの実行結果とgrepコマンドを繋ぐことで、Usersリソースに関するルーティングだけを表示させることができるが、
　 同様にして、Sessionsリソースに関する結果だけを表示させてみる。
　 　ヒント: パイプやgrepの使い方が分からない場合は 『コマンドライン編』の 「grepで検索する」を参考
 $ rails routes | grep sessions
  sessions_new GET    /sessions/new(.:format)                                                                  sessions#new
         login GET    /login(.:format)                                                                         sessions#new
               POST   /login(.:format)                                                                         sessions#create
        logout DELETE /logout(.:format)                                                                        sessions#destroy


<ログインフォーム>
[演習]
1. [sessions/new.html.erb]で定義したフォームで送信すると、Sessionsコントローラのcreateアクションに到達する。
　 Railsはこれをどうやって実現しているか、考えてみる。
 form_forヘルパーはpostメソッドを生成する。
 ログインフォームのHTMLでは、sessionコントローラとlogin_pathを引数に指定している。
 　→essionコントローラのcreateアクションが[sessions/new.html.erb]のform_forで指定されている。


<ユーザーの検索と認証>
[user && user.authenticate(…)の結果の組み合わせ]
　User	　　　　　　　Password	　　　　　　a && b
存在しない	　　　　何でもよい	　　　　　(nil && [オブジェクト]) == false
有効なユーザー	　　誤ったパスワード	　　(true && false) == false
有効なユーザー	　　正しいパスワード	　　(true && true) == true

[演習]
1. Railsコンソールを使って、[user && user.authenticate(…)の結果の組み合わせ]のそれぞれの式が合っているか確かめる。
　 まずはuser = nilの場合を、次にuser = User.firstとした場合を確かめてみる。
　 　ヒント: 必ず論理値オブジェクトとなるように、!!のテクニックを使う。例: !!(user && user.authenticate('foobar'))
 > user = nil
 => nil 
 
 > !!(user && user.authenticate('foobar'))
 => false 
 
 > user = User.first
  User Load (0.2ms)  SELECT  "users".* FROM "users" ORDER BY "users"."id" ASC LIMIT ?  [["LIMIT", 1]]
 => #<User id: 1, name: "Rails Tutorial", email: "example@railstutorial.org", created_at: "2022-03-07 08:23:24", 
      updated_at: "2022-03-07 08:23:24", password_digest: "$2a$10$Lp4OvemyURYb3FVk.MrMeOihflVLQf5MIJR9SuUn0JN..."> 
      
 > !!(user && user.authenticate('aaaaaa'))
 => true 
 
 > !!(user && user.authenticate('hogehoge'))
 => false
 
 