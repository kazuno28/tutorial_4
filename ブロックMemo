<ブロック>
配列と範囲はいずれも、ブロックを伴うさまざまなメソッドに対して応答することができる。
ブロックは、Rubyの極めて強力な機能であり、かつわかりにくい機能でもある。

>> (1..5).each { |i| puts 2 * i }
2
4
6
8
10
=> 1..5
上のコードでは、範囲オブジェクトである(1..5)に対して、eachメソッドを呼び出している。
メソッドに渡されている{ |i| puts 2 * i }が、ブロックと呼ばれる部分。
|i|では変数名が縦棒「|」に囲まれているが、これはブロック変数に対して使うRubyの構文で、
ブロックを操作するときに使う変数を指定する。
この場合、範囲オブジェクトのeachメソッドは、iという1つのローカル変数を使ってブロックを操作できる。
そして、範囲に含まれるそれぞれの値をこの変数に次々に代入してブロックを実行する。

ブロックであることを示すには波カッコ で囲みますが、次のようにdoとendで囲んで示すこともできる。
>> (1..5).each do |i|
?>   puts 2 * i
>> end
2
4
6
8
10
=> 1..5

ブロックには複数の行を記述できる。（実際ほとんどのブロックは複数行）
RailsチュートリアルではRuby共通の慣習に従って、短い1行のブロックには波カッコを使い、
長い1行や複数行のブロックにはdo..end記法を使っている。
>> (1..5).each do |number|
?>   puts 2 * number
>>   puts '--'
>> end
2
--
4
--
6
--
8
--
10
--
=> 1..5
今度はiの代わりにnumberを使っていることに注目！
この変数 (ブロック変数) の名前は固定されていない。

ブロックは見た目に反して奥が深く、ブロックを十分に理解するためには相当なプログラミング経験が必要。
ブロックを含むコードをたくさん読みこなすことでブロックの本質を会得する以外に方法はない。

 
 <mapメソッドなどを使ったブロックの使用例>
>> 3.times { puts "Betelgeuse!" }   # 3.timesではブロックに変数を使っていない
"Betelgeuse!"
"Betelgeuse!"
"Betelgeuse!"
=> 3
>> (1..5).map { |i| i**2 }          # 「**」記法は冪乗 (べき乗) 
=> [1, 4, 9, 16, 25]
>> %w[a b c]                        # %w で文字列の配列を作成
=> ["a", "b", "c"]
>> %w[a b c].map { |char| char.upcase }
=> ["A", "B", "C"]
>> %w[A B C].map { |char| char.downcase }
=> ["a", "b", "c"]

mapメソッドは、渡されたブロックを配列や範囲オブジェクトの各要素に対して適用し、その結果を返す。
また、後半の2つの例では、mapのブロック内で宣言した引数 (char) に対してメソッドを呼び出している。

こういったケースでは省略記法が一般的で、次のように書くこともできる。 (この記法を“symbol-to-proc”と呼ぶ)
>> %w[A B C].map { |char| char.downcase }
=> ["a", "b", "c"]
>> %w[A B C].map(&:downcase)
=> ["a", "b", "c"]


 <単体テスト>
test "should get home" do
  get static_pages_home_url
  assert_response :success
  assert_select "title", "Ruby on Rails Tutorial Sample App"
end

重要なのは、テストコードにdoというキーワードがあることに気付き、テストの本体が「そもそもブロックでできている」ことに気付くこと。
すなわち、このtestメソッドは文字列 (説明文) とブロックを引数にとり、テストが実行されるときにブロック内の文が実行される、ということが理解できる。

('a'..'z').to_a.shuffle[0..7].join
順を追ってこのコードを組み立ててみると、動作がよくわかる。
>> ('a'..'z').to_a                     # 英小文字を列挙した配列を作る
=> ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o",
"p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
>> ('a'..'z').to_a.shuffle             # シャッフルする
=> ["c", "g", "l", "k", "h", "z", "s", "i", "n", "d", "y", "u", "t", "j", "q",
"b", "r", "o", "f", "e", "w", "v", "m", "a", "x", "p"]
>> ('a'..'z').to_a.shuffle[0..7]       # 配列の冒頭8つの要素を取り出す
=> ["f", "w", "i", "a", "h", "p", "c", "x"]
>> ('a'..'z').to_a.shuffle[0..7].join  # 取り出した要素を結合して１つの文字列にする
=> "mznpybuj"


[演習]
1. 範囲オブジェクト0..16を使って、各要素の２乗を出力。
 > (0..16).map { |i| i**2 }
 => [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256] 
 
2. yeller (大声で叫ぶ) というメソッドを定義する。
　 このメソッドは、文字列の要素で構成された配列を受け取り、各要素を連結した後、大文字にして結果を返す。
　  Ex)yeller(['o', 'l', 'd'])と実行したとき、"OLD"という結果が返ってくれば成功。
　  ヒント:mapとupcaseとjoinメソッドを使ってみる。
　 > def yeller(big_voice)
   >  voice = big_voice.map { |c| c.upcase }.join
   >  puts voice
   > end

   > yeller(['o','l','d'])
    OLD
   => nil

3. random_subdomainというメソッドを定義する。
　 このメソッドはランダムな8文字を生成し、文字列として返す。
　  ヒント: サブドメインを作るときに使ったRubyコードをメソッド化したもの。
　 > def ramdom_subdomain 
　 >   puts ('a'..'z').to_a.shuffle[0..7].join
　 > end
　 
　 > ramdom_subdomain
　 => "kxdjcpd"
　 
4. 「?」の部分を、それぞれ適切なメソッドに置き換える。
　　 ヒント:split、shuffle、joinメソッドを組み合わせると、メソッドに渡された文字列 (引数) をシャッフルさせることができる。
   >> def string_shuffle(s)
   >>   s.?('').?.?
   >> end
   >> string_shuffle("foobar")
   => "oobfra"
 
 > def string_shuffle(s)
 >  s.split('').shuffle.join
 > end
 
 > string_shuffle("abcde")
 => "dbcea"
 